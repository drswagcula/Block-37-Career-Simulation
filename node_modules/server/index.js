const express = require('express');
const { Pool } = require('pg');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const { check, validationResult } = require('express-validator');
const dotenv = require('dotenv');
const request = require('supertest'); //Added supertest for testing

dotenv.config();

const app = express();
app.use(express.json());

const client = new Client({
    user: 'postgres',
    host: 'localhost',
    database: 'review_site_db', 
    password: 'UKYO0083', 
    port: 5432,
});

const secretKey = process.env.JWT_SECRET || 'your-secret-key'; // Fallback to a default key if not in .env
const saltRounds = 10;

// Test the database connection
pool.connect()
    .then(() => console.log('Database connected successfully'))
    .catch(err => console.error('Database connection error:', err));

// --- User Model ---
class User {
    constructor(id, username, password) {
        this.id = id;
        this.username = username;
        this.password = password; // Should be hashed
    }

    static async findById(id) {
        const query = 'SELECT * FROM users WHERE id = $1';
        const values = [id];
        const result = await pool.query(query);
        if (result.rows.length > 0) {
            const { id, username, password } = result.rows[0];
            return new User(id, username, password);
        }
        return null;
    }

      static async findByUsername(username) {
        const query = 'SELECT * FROM users WHERE username = $1';
        const values = [username];
        const result = await pool.query(query);
        if (result.rows.length > 0) {
            const { id, username, password } = result.rows[0];
            return new User(id, username, password);
        }
        return null;
    }

    static async create(username, password) {
        const hashedPassword = await bcrypt.hash(password, saltRounds);
        const query = 'INSERT INTO users (username, password) VALUES ($1, $2) RETURNING id, username';
        const values = [username, hashedPassword];
        const result = await pool.query(query);
        if (result.rows.length > 0) {
            const { id, username } = result.rows[0];
            return new User(id, username, hashedPassword);
        }
        return null;
    }
}

// --- Item Model ---
class Item {
    constructor(id, name, description) {
        this.id = id;
        this.name = name;
        this.description = description;
    }

    static async findAll() {
        const query = 'SELECT * FROM items';
        const result = await pool.query(query);
        return result.rows.map(row => new Item(row.id, row.name, row.description));
    }

    static async findById(id) {
        const query = 'SELECT * FROM items WHERE id = $1';
        const values = [id];
        const result = await pool.query(query);
        if (result.rows.length > 0) {
            const { id, name, description } = result.rows[0];
            return new Item(id, name, description);
        }
        return null;
    }
}

// --- Review Model ---
class Review {
    constructor(id, userId, itemId, reviewText, rating) {
        this.id = id;
        this.userId = userId;
        this.itemId = itemId;
        this.reviewText = reviewText;
        this.rating = rating;
    }

    static async findById(id) {
        const query = 'SELECT * FROM reviews WHERE id = $1';
        const values = [id];
        const result = await pool.query(query);
        if (result.rows.length > 0) {
            const { id, user_id, item_id, review_text, rating } = result.rows[0];
            return new Review(id, user_id, item_id, review_text, rating);
        }
        return null;
    }

    static async findAllByItemId(itemId) {
      const query = 'SELECT * FROM reviews WHERE item_id = $1';
      const values = [itemId];
      const result = await pool.query(query);
      return result.rows.map(row => new Review(row.id, row.user_id, row.item_id, row.review_text, row.rating));
    }

      static async findAllByUserId(userId) {
        const query = 'SELECT * FROM reviews WHERE user_id = $1';
        const values = [userId];
        const result = await pool.query(query);
        return result.rows.map(row => new Review(row.id, row.user_id, row.item_id, row.review_text, row.rating));
    }

    static async create(userId, itemId, reviewText, rating) {
        const query = 'INSERT INTO reviews (user_id, item_id, review_text, rating) VALUES ($1, $2, $3, $4) RETURNING id, user_id, item_id, review_text, rating';
        const values = [userId, itemId, reviewText, rating];
        const result = await pool.query(query);
        if (result.rows.length > 0) {
            const { id, user_id, item_id, review_text, rating } = result.rows[0];
            return new Review(id, user_id, item_id, review_text, rating);
        }
        return null;
    }

    static async update(userId, reviewId, reviewText, rating) {
        const query = 'UPDATE reviews SET review_text = $1, rating = $2 WHERE id = $3 AND user_id = $4 RETURNING id, user_id, item_id, review_text, rating';
        const values = [reviewText, rating, reviewId, userId];
        const result = await pool.query(query);
        if (result.rows.length > 0) {
          const { id, user_id, item_id, review_text, rating } = result.rows[0];
          return new Review(id, user_id, item_id, review_text, rating);
        }
        return null;
    }

    static async delete(userId, reviewId) {
        const query = 'DELETE FROM reviews WHERE id = $1 AND user_id = $2';
        const values = [reviewId, userId];
        const result = await pool.query(query);
        return result.rowCount > 0;
    }
}

// --- Comment Model ---
class Comment {
  constructor(id, userId, reviewId, commentText) {
    this.id = id;
    this.userId = userId;
    this.reviewId = reviewId;
    this.commentText = commentText;
  }

  static async findById(id) {
        const query = 'SELECT * FROM comments WHERE id = $1';
        const values = [id];
        const result = await pool.query(query);
        if (result.rows.length > 0) {
            const { id, user_id, review_id, comment_text } = result.rows[0];
            return new Comment(id, user_id, review_id, comment_text);
        }
        return null;
    }

  static async findAllByUserId(userId) {
    const query = 'SELECT * FROM comments WHERE user_id = $1';
    const values = [userId];
    const result = await pool.query(query);
    return result.rows.map(row => new Comment(row.id, row.user_id, row.review_id, row.comment_text));
  }

  static async create(userId, reviewId, commentText) {
    const query = 'INSERT INTO comments (user_id, review_id, comment_text) VALUES ($1, $2, $3) RETURNING id, user_id, review_id, comment_text';
    const values = [userId, reviewId, commentText];
    const result = await pool.query(query);
    if (result.rows.length > 0) {
      const { id, user_id, review_id, comment_text } = result.rows[0];
      return new Comment(id, user_id, review_id, comment_text);
    }
    return null;
  }

  static async update(userId, commentId, commentText) {
        const query = 'UPDATE comments SET comment_text = $1 WHERE id = $2 AND user_id = $3 RETURNING id, user_id, review_id, comment_text';
        const values = [commentText, commentId, userId];
        const result = await pool.query(query);
        if (result.rows.length > 0) {
          const { id, user_id, review_id, comment_text } = result.rows[0];
          return new Comment(id, user_id, review_id, comment_text);
        }
        return null;
    }

  static async delete(userId, commentId) {
    const query = 'DELETE FROM comments WHERE id = $1 AND user_id = $2';
    const values = [commentId, userId];
    const result = await pool.query(query);
    return result.rowCount > 0;
  }
}

// --- Middleware ---
const authenticateToken = (req, res, next) => {
    const authHeader = req.headers.authorization;
    if (authHeader) {
        const token = authHeader.split(' ')[1];
        jwt.verify(token, secretKey, (err, user) => {
            if (err) {
                return res.sendStatus(403);
            }
            req.user = user;
            next();
        });
    } else {
        res.sendStatus(401);
    }
};

// --- Routes ---

// POST /api/auth/register
app.post('/api/auth/register', [
    check('username').isLength({ min: 3 }).withMessage('Username must be at least 3 characters long'),
    check('password').isLength({ min: 6 }).withMessage('Password must be at least 6 characters long')
], async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }

    const { username, password } = req.body;
    try {
        const existingUser = await User.findByUsername(username);
        if (existingUser) {
            return res.status(400).json({ message: 'Username already exists' });
        }
        const newUser = await User.create(username, password);
        const token = jwt.sign({ userId: newUser.id, username: newUser.username }, secretKey);
        res.status(201).json({ token, user: { id: newUser.id, username: newUser.username } });
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Internal server error' });
    }
});

// POST /api/auth/login
app.post('/api/auth/login', async (req, res) => {
    const { username, password } = req.body;
    try {
        const user = await User.findByUsername(username);
        if (!user) {
            return res.status(401).json({ message: 'Invalid credentials' });
        }
        const passwordMatch = await bcrypt.compare(password, user.password);
        if (!passwordMatch) {
            return res.status(401).json({ message: 'Invalid credentials' });
        }
        const token = jwt.sign({ userId: user.id, username: user.username }, secretKey);
        res.json({ token, user: { id: user.id, username: user.username } });
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Internal server error' });
    }
});

// GET /api/auth/me (check token on this)
app.get('/api/auth/me', authenticateToken, async (req, res) => {
    try {
        const user = await User.findById(req.user.userId);
        if (!user) {
            return res.status(404).json({ message: 'User not found' }); //Shouldn't happen, unless token is invalid
        }
        res.json({ user: { id: user.id, username: user.username } });
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Internal server error' });
    }
});

// GET /api/items
app.get('/api/items', async (req, res) => {
    try {
        const items = await Item.findAll();
        res.json(items);
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Internal server error' });
    }
});

// GET /api/items/:itemId
app.get('/api/items/:itemId', async (req, res) => {
    const { itemId } = req.params;
    try {
        const item = await Item.findById(itemId);
        if (!item) {
            return res.status(404).json({ message: 'Item not found' });
        }
        res.json(item);
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Internal server error' });
    }
});

// GET /api/items/:itemId/reviews
app.get('/api/items/:itemId/reviews', async (req, res) => {
    const { itemId } = req.params;
    try {
        const reviews = await Review.findAllByItemId(itemId);
        res.json(reviews);
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Internal server error' });
    }
});

// GET /api/items/:itemId/reviews/:reviewId
app.get('/api/items/:itemId/reviews/:reviewId', async (req, res) => {
    const { reviewId } = req.params;
    try {
        const review = await Review.findById(reviewId);
        if (!review) {
            return res.status(404).json({ message: 'Review not found' });
        }
        res.json(review);
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Internal server error' });
    }
});

// POST /api/items/:itemId/reviews (check token on this)
app.post('/api/items/:itemId/reviews', authenticateToken, [
    check('reviewText').notEmpty().withMessage('Review text is required'),
    check('rating').isInt({ min: 1, max: 5 }).withMessage('Rating must be an integer between 1 and 5')
], async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }

    const { itemId } = req.params;
    const { reviewText, rating } = req.body;
    const userId = req.user.userId;
    try {
        // Check if the item exists
        const item = await Item.findById(itemId);
        if (!item) {
            return res.status(404).json({ message: 'Item not found' });
        }
        //Check if user already has a review for this item
        const existingReviews = await Review.findAllByUserId(userId);
        const hasExistingReview = existingReviews.some(review => review.itemId === parseInt(itemId));

        if (hasExistingReview) {
             return res.status(400).json({ message: 'User already has a review for this item' });
        }

        const newReview = await Review.create(userId, itemId, reviewText, rating);
        res.status(201).json(newReview);
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Internal server error' });
    }
});

// GET /api/reviews/me (check token on this)
app.get('/api/reviews/me', authenticateToken, async (req, res) => {
    const userId = req.user.userId;
    try {
        const reviews = await Review.findAllByUserId(userId);
        res.json(reviews);
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Internal server error' });
    }
});

// PUT /api/users/:userId/reviews/:reviewId (check token on this)
app.put('/api/users/:userId/reviews/:reviewId', authenticateToken, [
    check('reviewText').notEmpty().withMessage('Review text is required'),
    check('rating').isInt({ min: 1, max: 5 }).withMessage('Rating must be an integer between 1 and 5')
], async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }
    const { userId, reviewId } = req.params;
    const { reviewText, rating } = req.body;
    if (parseInt(userId) !== req.user.userId) {
        return res.status(403).json({ message: 'Unauthorized' });
    }
    try {
        const updatedReview = await Review.update(userId, reviewId, reviewText, rating);
        if (!updatedReview) {
            return res.status(404).json({ message: 'Review not found or unauthorized' });
        }
        res.json(updatedReview);
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Internal server error' });
    }
});

// DELETE /api/users/:userId/reviews/:reviewId (check token on this)
app.delete('/api/users/:userId/reviews/:reviewId', authenticateToken, async (req, res) => {
    const { userId, reviewId } = req.params;
     if (parseInt(userId) !== req.user.userId) {
        return res.status(403).json({ message: 'Unauthorized' });
    }
    try {
        const deleted = await Review.delete(userId, reviewId);
        if (!deleted) {
            return res.status(404).json({ message: 'Review not found or unauthorized' });
        }
        res.status(204).send();
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Internal server error' });
    }
});

// POST /api/items/:itemId/reviews/:reviewId/comments (check token on this)
app.post('/api/items/:itemId/reviews/:reviewId/comments', authenticateToken, [
    check('commentText').notEmpty().withMessage('Comment text is required')
], async (req, res) => {
    const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }
    const { reviewId } = req.params;
    const { commentText } = req.body;
    const userId = req.user.userId;
    try {
        // Check if the review exists
        const review = await Review.findById(reviewId);
        if (!review) {
            return res.status(404).json({ message: 'Review not found' });
        }
        const newComment = await Comment.create(userId, reviewId, commentText);
        res.status(201).json(newComment);
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Internal server error' });
    }
});

// GET /api/comments/me (check token on this)
app.get('/api/comments/me', authenticateToken, async (req, res) => {
  const userId = req.user.userId;
  try {
    const comments = await Comment.findAllByUserId(userId);
    res.json(comments);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Internal server error' });
  }
});

// PUT /api/users/:userId/comments/:commentId (check token on this)
app.put('/api/users/:userId/comments/:commentId', authenticateToken, [
  check('commentText').notEmpty().withMessage('Comment text is required')
], async (req, res) => {
  const { userId, commentId } = req.params;
  const { commentText } = req.body;
   if (parseInt(userId) !== req.user.userId) {
        return res.status(403).json({ message: 'Unauthorized' });
    }
  try {
    const updatedComment = await Comment.update(userId, commentId, commentText);
    if (!updatedComment) {
      return res.status(404).json({ message: 'Comment not found or unauthorized' });
    }
    res.json(updatedComment);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Internal server error' });
  }
});

// DELETE /api/users/:userId/comments/:commentId (check token on this)
app.delete('/api/users/:userId/comments/:commentId', authenticateToken, async (req, res) => {
  const { userId, commentId } = req.params;
   if (parseInt(userId) !== req.user.userId) {
        return res.status(403).json({ message: 'Unauthorized' });
    }
  try {
    const deleted = await Comment.delete(userId, commentId);
    if (!deleted) {
      return res.status(404).json({ message: 'Comment not found or unauthorized' });
    }
    res.status(204).send();
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Internal server error' });
  }
});

// --- Tests (using supertest) ---
if (process.env.NODE_ENV === 'test') {
  describe('User API Endpoints', () => {
    let server;
    let testUser;
    let testToken;

    beforeAll((done) => {
      server = app.listen(0, () => {
        const { port } = server.address();
        process.env.TEST_PORT = port;  // Set the port
        done();
      });
    });

    afterAll((done) => {
      server.close(done);
    });

    beforeEach(async () => {
      // Clear database and create a test user before each test
      await pool.query('DELETE FROM comments');
      await pool.query('DELETE FROM reviews');
      await pool.query('DELETE FROM users');
      await pool.query('DELETE FROM items');

      // Create a test user
      const password = 'testpassword';
      const hashedPassword = await bcrypt.hash(password, saltRounds);
      const userResult = await pool.query(
        'INSERT INTO users (username, password) VALUES ($1, $2) RETURNING id, username',
        ['testuser', hashedPassword]
      );
      testUser = userResult.rows[0];

      // Create a test item
      const itemResult = await pool.query(
        'INSERT INTO items (name, description) VALUES ($1, $2) RETURNING id',
        ['testitem', 'test description']
      );
      testItem = itemResult.rows[0];

      // Generate a token for the test user
      testToken = jwt.sign({ userId: testUser.id, username: testUser.username }, secretKey);
    });

    // --- User Tests ---
    it('should register a new user', async () => {
      const res = await request(app)
        .post('/api/auth/register')
        .send({ username: 'newuser', password: 'newpassword' });
      expect(res.statusCode).toBe(201);
      expect(res.body).toHaveProperty('token');
      expect(res.body.user).toHaveProperty('id');
      expect(res.body.user.username).toBe('newuser');
    });

    it('should login an existing user', async () => {
      const res = await request(app)
        .post('/api/auth/login')
        .send({ username: 'testuser', password: 'testpassword' });
      expect(res.statusCode).toBe(200);
      expect(res.body).toHaveProperty('token');
      expect(res.body.user).toHaveProperty('id');
      expect(res.body.user.username).toBe('testuser');
    });

    it('should get user data from token', async () => {
      const res = await request(app)
        .get('/api/auth/me')
        .set('Authorization', `Bearer ${testToken}`);
      expect(res.statusCode).toBe(200);
      expect(res.body.user.id).toBe(testUser.id);
      expect(res.body.user.username).toBe(testUser.username);
    });

    // --- Item Tests ---
      it('should get all items', async () => {
        const res = await request(app).get('/api/items');
        expect(res.statusCode).toBe(200);
        expect(res.body).toBeInstanceOf(Array);
        expect(res.body.length).toBeGreaterThan(0);
    });

    it('should get a specific item', async () => {
        const res = await request(app).get(`/api/items/${testItem.id}`);
        expect(res.statusCode).toBe(200);
        expect(res.body).toHaveProperty('id');
        expect(res.body.name).toBe('testitem');
    });

    // --- Review Tests ---
    it('should create a new review for an item', async () => {
      const res = await request(app)
        .post(`/api/items/${testItem.id}/reviews`)
        .set('Authorization', `Bearer ${testToken}`)
        .send({ reviewText: 'Great product!', rating: 5 });
      expect(res.statusCode).toBe(201);
      expect(res.body).toHaveProperty('id');
      expect(res.body.reviewText).toBe('Great product!');
      expect(res.body.rating).toBe(5);
      expect(res.body.user_id).toBe(testUser.id);
      expect(res.body.item_id).toBe(testItem.id);
    });

    it('should get all reviews for an item', async () => {
        // Create a review first
        await request(app)
          .post(`/api/items/${testItem.id}/reviews`)
          .set('Authorization', `Bearer ${testToken}`)
          .send({ reviewText: 'Good product', rating: 4 });

        const res = await request(app).get(`/api/items/${testItem.id}/reviews`);
        expect(res.statusCode).toBe(200);
        expect(res.body).toBeInstanceOf(Array);
        expect(res.body.length).toBeGreaterThan(0);
    });

    it('should get a single review by ID', async () => {
        // First create a review
        const reviewResponse = await request(app)
            .post(`/api/items/${testItem.id}/reviews`)
            .set('Authorization', `Bearer ${testToken}`)
            .send({ reviewText: 'Excellent!', rating: 5 });

        const reviewId = reviewResponse.body.id;

        const res = await request(app).get(`/api/items/${testItem.id}/reviews/${reviewId}`);
        expect(res.statusCode).toBe(200);
        expect(res.body.id).toBe(reviewId);
        expect(res.body.reviewText).toBe('Excellent!');
        expect(res.body.rating).toBe(5);
    });

    it('should get all reviews for a user', async () => {
      // Create two reviews for the user
      await request(app)
        .post(`/api/items/${testItem.id}/reviews`)
        .set('Authorization', `Bearer ${testToken}`)
        .send({ reviewText: 'Review 1', rating: 3 });
      await request(app)
        .post(`/api/items/${testItem.id}/reviews`)
        .set('Authorization', `Bearer ${testToken}`)
        .send({ reviewText: 'Review 2', rating: 4 });

      const res = await request(app)
        .get('/api/reviews/me')
        .set('Authorization', `Bearer ${testToken}`);
      expect(res.statusCode).toBe(200);
      expect(res.body).toBeInstanceOf(Array);
      expect(res.body.length).toBe(2);
    });

    it('should update a review', async () => {
        // First, create a review
        const createResponse = await request(app)
            .post(`/api/items/${testItem.id}/reviews`)
            .set('Authorization', `Bearer ${testToken}`)
            .send({ reviewText: 'Initial review', rating: 2 });
        const reviewId = createResponse.body.id;

        const res = await request(app)
            .put(`/api/users/${testUser.id}/reviews/${reviewId}`)
            .set('Authorization', `Bearer ${testToken}`)
            .send({ reviewText: 'Updated review', rating: 5 });
        expect(res.statusCode).toBe(200);
        expect(res.body.reviewText).toBe('Updated review');
        expect(res.body.rating).toBe(5);
    });

    it('should delete a review', async () => {
      // First create a review
      const reviewResponse = await request(app)
        .post(`/api/items/${testItem.id}/reviews`)
        .set('Authorization', `Bearer ${testToken}`)
        .send({ reviewText: 'To be deleted', rating: 1 });
      const reviewId = reviewResponse.body.id;

      const res = await request(app)
        .delete(`/api/users/${testUser.id}/reviews/${reviewId}`)
        .set('Authorization', `Bearer ${testToken}`);
      expect(res.statusCode).toBe(204);

      // Verify that the review is deleted
      const getResponse = await request(app).get(`/api/items/${testItem.id}/reviews/${reviewId}`);
      expect(getResponse.statusCode).toBe(404);
    });

    // --- Comment Tests ---
    it('should create a comment on a review', async () => {
        // First, create a review to comment on
        const reviewResponse = await request(app)
            .post(`/api/items/${testItem.id}/reviews`)
            .set('Authorization', `Bearer ${testToken}`)
            .send({ reviewText: 'Review to comment on', rating: 4 });
        const reviewId = reviewResponse.body.id;

        const res = await request(app)
            .post(`/api/items/${testItem.id}/reviews/${reviewId}/comments`)
            .set('Authorization', `Bearer ${testToken}`)
            .send({ commentText: 'This is a comment' });
        expect(res.statusCode).toBe(201);
        expect(res.body).toHaveProperty('id');
        expect(res.body.comment_text).toBe('This is a comment');
        expect(res.body.user_id).toBe(testUser.id);
        expect(res.body.review_id).toBe(reviewId);
    });

    it('should get all comments for a user', async () => {
      // Create two comments for the user
      const reviewResponse1 = await request(app)
        .post(`/api/items/${testItem.id}/reviews`)
        .set('Authorization', `Bearer ${testToken}`)
        .send({ reviewText: 'Review 1', rating: 3 });
      const reviewId1 = reviewResponse1.body.id;

      const reviewResponse2 = await request(app)
        .post(`/api/items/${testItem.id}/reviews`)
        .set('Authorization', `Bearer ${testToken}`)
        .send({ reviewText: 'Review 2', rating: 4 });
      const reviewId2 = reviewResponse2.body.id;

      await request(app)
        .post(`/api/items/${testItem.id}/reviews/${reviewId1}/comments`)
        .set('Authorization', `Bearer ${testToken}`)
        .send({ commentText: 'Comment 1' });
      await request(app)
        .post(`/api/items/${testItem.id}/reviews/${reviewId2}/comments`)
        .set('Authorization', `Bearer ${testToken}`)
        .send({ commentText: 'Comment 2' });

      const res = await request(app)
        .get('/api/comments/me')
        .set('Authorization', `Bearer ${testToken}`);
      expect(res.statusCode).toBe(200);
      expect(res.body).toBeInstanceOf(Array);
      expect(res.body.length).toBe(2);
    });

    it('should update a comment', async () => {
        // First, create a review and a comment
        const reviewResponse = await request(app)
            .post(`/api/items/${testItem.id}/reviews`)
            .set('Authorization', `Bearer ${testToken}`)
            .send({ reviewText: 'Review to comment on', rating: 4 });
        const reviewId = reviewResponse.body.id;

        const commentResponse = await request(app)
            .post(`/api/items/${testItem.id}/reviews/${reviewId}/comments`)
            .set('Authorization', `Bearer ${testToken}`)
            .send({ commentText: 'Original comment' });
        const commentId = commentResponse.body.id;

        const res = await request(app)
            .put(`/api/users/${testUser.id}/comments/${commentId}`)
            .set('Authorization', `Bearer ${testToken}`)
            .send({ commentText: 'Updated comment' });
        expect(res.statusCode).toBe(200);
        expect(res.body.comment_text).toBe('Updated comment');
    });

    it('should delete a comment', async () => {
       // First, create a review and a comment
        const reviewResponse = await request(app)
            .post(`/api/items/${testItem.id}/reviews`)
            .set('Authorization', `Bearer ${testToken}`)
            .send({ reviewText: 'Review to comment on', rating: 4 });
        const reviewId = reviewResponse.body.id;

        const commentResponse = await request(app)
            .post(`/api/items/${testItem.id}/reviews/${reviewId}/comments`)
            .set('Authorization', `Bearer ${testToken}`)
            .send({ commentText: 'To be deleted' });
        const commentId = commentResponse.body.id;

        const res = await request(app)
            .delete(`/api/users/${testUser.id}/comments/${commentId}`)
            .set('Authorization', `Bearer ${testToken}`);
        expect(res.statusCode).toBe(204);

        // Verify that the comment is deleted
        const getResponse = await request(app).get(`/api/items/${testItem.id}/reviews/${reviewId}/comments/${commentId}`);
        expect(getResponse.statusCode).toBe(404);
    });
  });
}

// Only start the server if not in test environment
if (process.env.NODE_ENV !== 'test') {
    app.listen(3000, () => {
        console.log('Server is running on port 3000');
    });
}

module.exports = app; // For testing
